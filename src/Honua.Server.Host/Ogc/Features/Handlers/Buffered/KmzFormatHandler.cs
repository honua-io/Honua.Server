// Copyright (c) 2025 HonuaIO
// Licensed under the Elastic License 2.0. See LICENSE file in the project root for full license information.
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Honua.Server.Core.Data;
using Honua.Server.Core.Extensions;
using Honua.Server.Core.Serialization;
using Honua.Server.Core.Styling;
using Honua.Server.Core.Utilities;
using Honua.Server.Host.Utilities;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;

namespace Honua.Server.Host.Ogc.Features.Handlers.Buffered;

/// <summary>
/// Format handler for KMZ (Compressed KML) output format.
/// KMZ is a ZIP archive containing a KML document and optional supporting files
/// (images, icons, etc.). This handler generates KML content and packages it
/// into a compressed archive for efficient distribution.
/// </summary>
/// <remarks>
/// KMZ format characteristics:
/// - Output: ZIP archive (.kmz) containing KML document
/// - MIME type: application/vnd.google-earth.kmz
/// - Streaming: No (requires buffering for archive creation)
/// - Memory efficient: No (all features buffered, plus compression)
/// - Supports: All KML features plus embedded assets
/// - CRS: Only supports CRS84 (WGS84) coordinates
/// - Compression: ZIP with fastest compression level
/// - Limitations: Requires coordinate transformation to WGS84
///
/// KMZ Archive Structure:
/// KMZ archives follow the KML 2.3 specification for compressed archives:
/// - Primary KML document with sanitized filename based on collection ID
/// - Optional asset files (not currently included but supported by builder)
/// - ZIP compression for efficient network transfer
/// - Archive entry names validated to prevent path traversal
///
/// Relationship to KML:
/// KMZ is essentially a compressed KML document. This handler reuses the same
/// KML generation logic as <see cref="KmlFormatHandler"/> but packages the
/// result in a ZIP archive using <see cref="KmzArchiveBuilder"/>.
/// </remarks>
public sealed class KmzFormatHandler : Crs84RequiredFormatHandlerBase
{
    /// <inheritdoc/>
    /// <remarks>
    /// Returns <see cref="OgcResponseFormat.Kmz"/>.
    /// </remarks>
    public override OgcResponseFormat Format => OgcResponseFormat.Kmz;

    /// <inheritdoc/>
    /// <remarks>
    /// Returns "KMZ" for use in validation error messages.
    /// </remarks>
    protected override string GetFormatDisplayName() => "KMZ";

    /// <inheritdoc/>
    /// <remarks>
    /// Generates a KMZ archive containing a KML document from buffered features.
    /// The implementation follows these steps:
    /// <list type="number">
    /// <item><description>Resolves the layer's default style for KML styling</description></item>
    /// <item><description>Converts buffered feature records to KML feature content</description></item>
    /// <item><description>Generates the complete KML document with styles and metadata</description></item>
    /// <item><description>Packages the KML in a ZIP archive with proper entry naming</description></item>
    /// <item><description>Returns the KMZ as a downloadable archive with cache headers</description></item>
    /// </list>
    ///
    /// The handler expects <see cref="FormatRequest.BufferedFeatures"/> to contain
    /// <see cref="FeatureRecord"/> objects which are converted to KML placemarks,
    /// then packaged in a ZIP archive.
    ///
    /// Archive Entry Naming:
    /// The KML document within the archive is named using a sanitized version
    /// of the collection ID to ensure valid filenames and prevent path traversal.
    /// The entry name is generated by <see cref="FileNameHelper.BuildArchiveEntryName"/>.
    ///
    /// Style Resolution:
    /// Style resolution follows the same priority as <see cref="KmlFormatHandler"/>:
    /// <list type="number">
    /// <item><description>Layer's default style ID if specified</description></item>
    /// <item><description>First style ID in the layer's style list</description></item>
    /// <item><description>Fallback to "default" style if no styles configured</description></item>
    /// </list>
    /// </remarks>
    /// <param name="request">The format request containing layer metadata, query parameters, and buffered features.</param>
    /// <param name="cancellationToken">Cancellation token for async operations.</param>
    /// <returns>
    /// A file result containing the KMZ archive with:
    /// <list type="bullet">
    /// <item><description>MIME type: application/vnd.google-earth.kmz</description></item>
    /// <item><description>File name: {collection-id}.kmz</description></item>
    /// <item><description>Cache headers for feature resources</description></item>
    /// <item><description>ETag computed from archive content</description></item>
    /// </list>
    /// </returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="request"/> is null.</exception>
    /// <exception cref="InvalidOperationException">
    /// Thrown when buffered features are null or when KML/KMZ conversion fails.
    /// </exception>
    public override async Task<IResult> HandleAsync(
        FormatRequest request,
        CancellationToken cancellationToken)
    {
        Guard.NotNull(request);

        // Ensure we have buffered features
        if (request.BufferedFeatures is null)
        {
            throw new InvalidOperationException(
                "KMZ format requires buffered features. The FormatRequest.BufferedFeatures property must not be null.");
        }

        // Resolve the layer's style for KML styling
        // Priority: DefaultStyleId > first StyleId > "default"
        var preferredStyleId = request.Layer.DefaultStyleId.HasValue()
            ? request.Layer.DefaultStyleId
            : request.Layer.StyleIds.Count > 0
                ? request.Layer.StyleIds[0]
                : "default";

        var kmlStyle = await OgcSharedHandlers.ResolveStyleDefinitionAsync(
            preferredStyleId!,
            request.Layer,
            request.Dependencies.MetadataRegistry,
            cancellationToken).ConfigureAwait(false);

        // Convert buffered feature records to KML feature content
        // This creates placemarks with geometry, names, and extended data
        var kmlFeatures = new List<KmlFeatureContent>();
        var query = EnforceCrs84(request.Query);

        foreach (var bufferedFeature in request.BufferedFeatures)
        {
            if (bufferedFeature is FeatureRecord record)
            {
                var kmlContent = FeatureComponentBuilder.CreateKmlContent(
                    request.Layer,
                    record,
                    query);
                kmlFeatures.Add(kmlContent);
            }
        }

        // Record metrics for features returned
        var numberReturned = kmlFeatures.Count;
        FormatHandlerHelpers.RecordFeaturesReturned(request, numberReturned);

        try
        {
            // Generate the complete KML document with styles and features
            var matchedValue = request.NumberMatched ?? numberReturned;
            var payload = KmlFeatureFormatter.WriteFeatureCollection(
                request.CollectionId,
                request.Layer,
                kmlFeatures,
                matchedValue,
                numberReturned,
                kmlStyle);

            // Package the KML document in a KMZ (ZIP) archive
            // Entry name is sanitized to ensure valid filenames
            var entryName = FileNameHelper.BuildArchiveEntryName(request.CollectionId, null);
            var archive = KmzArchiveBuilder.CreateArchive(payload, entryName);

            // Prepare file response
            var downloadName = FileNameHelper.BuildDownloadFileName(request.CollectionId, null, "kmz");
            var mimeType = OgcSharedHandlers.GetMimeType(Format);

            // Generate ETag for cache validation
            var etag = request.Dependencies.CacheHeaderService.GenerateETag(archive);

            // Return the KMZ archive with cache headers
            return Results.File(archive, mimeType, downloadName)
                .WithFeatureCacheHeaders(request.Dependencies.CacheHeaderService, etag);
        }
        catch (InvalidOperationException)
        {
            // KML/KMZ conversion can fail if geometry types are unsupported or malformed
            return Results.Problem(
                "KML conversion failed. Check server logs for details.",
                statusCode: StatusCodes.Status500InternalServerError,
                title: "KML conversion failed");
        }
    }
}
