// Copyright (c) 2025 HonuaIO
// Licensed under the Elastic License 2.0. See LICENSE file in the project root for full license information.
using System;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Dapper;
using Honua.Server.Enterprise.Sensors.Models;
using Honua.Server.Enterprise.Sensors.Query;
using Microsoft.Extensions.Logging;
using NetTopologySuite.Geometries;
using NetTopologySuite.IO;
using Npgsql;
using StaLocation = Honua.Server.Enterprise.Sensors.Models.Location;

namespace Honua.Server.Enterprise.Sensors.Data.Postgres;

/// <summary>
/// PostgreSQL implementation for HistoricalLocation entity operations (read-only).
/// HistoricalLocations are auto-generated by database triggers.
/// </summary>
internal sealed class PostgresHistoricalLocationRepository
{
    private readonly string _connectionString;
    private readonly ILogger _logger;
    private readonly string _basePath;
    private readonly GeoJsonReader _geoJsonReader;

    public PostgresHistoricalLocationRepository(string connectionString, string basePath, ILogger logger)
    {
        _connectionString = connectionString;
        _basePath = basePath;
        _logger = logger;
        _geoJsonReader = new GeoJsonReader();
    }

    public async Task<HistoricalLocation?> GetByIdAsync(string id, ExpandOptions? expand, CancellationToken ct)
    {
        await using var conn = new NpgsqlConnection(_connectionString);
        await conn.OpenAsync(ct);

        const string sql = """
            SELECT
                id::text,
                thing_id::text,
                time,
                created_at
            FROM sta_historical_locations
            WHERE id = @Id::uuid
            """;

        var historicalLocation = await conn.QuerySingleOrDefaultAsync<HistoricalLocation>(
            new CommandDefinition(sql, new { Id = id }, cancellationToken: ct));

        if (historicalLocation != null)
        {
            historicalLocation = historicalLocation with { SelfLink = $"{_basePath}/HistoricalLocations({historicalLocation.Id})" };

            // Handle expansions
            if (expand?.Properties.Contains("Locations") == true)
            {
                const string locationsSql = """
                    SELECT l.id::text, l.name, l.description, l.encoding_type,
                           ST_AsGeoJSON(l.location)::jsonb as location_geojson,
                           l.properties, l.created_at, l.updated_at
                    FROM sta_locations l
                    JOIN sta_historical_location_location hll ON l.id = hll.location_id
                    WHERE hll.historical_location_id = @HistoricalLocationId::uuid
                    """;

                var results = await conn.QueryAsync<dynamic>(
                    new CommandDefinition(locationsSql, new { HistoricalLocationId = id }, cancellationToken: ct));

                var locations = results.Select(r => new StaLocation
                {
                    Id = r.id,
                    Name = r.name,
                    Description = r.description,
                    EncodingType = r.encoding_type,
                    Geometry = _geoJsonReader.Read<Geometry>(r.location_geojson.ToString()),
                    Properties = r.properties,
                    CreatedAt = r.created_at,
                    UpdatedAt = r.updated_at,
                    SelfLink = $"{_basePath}/Locations({r.id})"
                }).ToList();

                historicalLocation = historicalLocation with { Locations = locations };
            }
        }

        return historicalLocation;
    }

    public async Task<PagedResult<HistoricalLocation>> GetPagedAsync(QueryOptions options, CancellationToken ct)
    {
        await using var conn = new NpgsqlConnection(_connectionString);
        await conn.OpenAsync(ct);

        var sql = "SELECT id::text, thing_id::text, time, created_at FROM sta_historical_locations";
        var countSql = "SELECT COUNT(*) FROM sta_historical_locations";
        var parameters = new DynamicParameters();

        if (options.Filter != null)
        {
            var whereClause = PostgresQueryHelper.TranslateFilter(options.Filter, parameters);
            sql += $" WHERE {whereClause}";
            countSql += $" WHERE {whereClause}";
        }

        if (options.OrderBy?.Count > 0)
        {
            var orderClauses = options.OrderBy.Select(o =>
                $"{o.Property} {(o.Direction == SortDirection.Descending ? "DESC" : "ASC")}");
            sql += $" ORDER BY {string.Join(", ", orderClauses)}";
        }
        else
        {
            sql += " ORDER BY time DESC";
        }

        var limit = Math.Min(options.Top ?? 100, 10000);
        var offset = options.Skip ?? 0;
        sql += $" LIMIT {limit} OFFSET {offset}";

        var historicalLocations = await conn.QueryAsync<HistoricalLocation>(
            new CommandDefinition(sql, parameters, cancellationToken: ct));

        var historicalLocationsWithLinks = historicalLocations.Select(hl => hl with { SelfLink = $"{_basePath}/HistoricalLocations({hl.Id})" }).ToList();

        long? totalCount = null;
        if (options.Count)
        {
            totalCount = await conn.ExecuteScalarAsync<long>(
                new CommandDefinition(countSql, parameters, cancellationToken: ct));
        }

        string? nextLink = null;
        if (totalCount.HasValue && offset + limit < totalCount.Value)
        {
            nextLink = $"{_basePath}/HistoricalLocations?$skip={offset + limit}&$top={limit}";
        }

        return new PagedResult<HistoricalLocation>
        {
            Items = historicalLocationsWithLinks,
            TotalCount = totalCount,
            NextLink = nextLink
        };
    }
}
