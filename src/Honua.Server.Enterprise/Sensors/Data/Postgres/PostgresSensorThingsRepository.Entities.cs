using System;
using System.Linq;
using System.Text;
using System.Text.Json;
using Dapper;
using Honua.Server.Enterprise.Sensors.Models;
using Honua.Server.Enterprise.Sensors.Query;
using Microsoft.Extensions.Logging;
using Geometry = NetTopologySuite.Geometries.Geometry;
using StaLocation = Honua.Server.Enterprise.Sensors.Models.Location;

namespace Honua.Server.Enterprise.Sensors.Data.Postgres;

/// <summary>
/// Partial class containing operations for Sensor, ObservedProperty, FeatureOfInterest, and HistoricalLocation entities.
/// These are supporting entities in the SensorThings API data model.
/// </summary>
public sealed partial class PostgresSensorThingsRepository
{
    // ============================================================================
    // HistoricalLocation operations (read-only - auto-generated by trigger)
    // ============================================================================

    public async Task<HistoricalLocation?> GetHistoricalLocationAsync(string id, ExpandOptions? expand = null, CancellationToken ct = default)
    {
        const string sql = """
            SELECT
                id::text,
                thing_id::text,
                time,
                created_at
            FROM sta_historical_locations
            WHERE id = @Id::uuid
            """;

        var historicalLocation = await _connection.QuerySingleOrDefaultAsync<HistoricalLocation>(
            new CommandDefinition(sql, new { Id = id }, cancellationToken: ct));

        if (historicalLocation != null)
        {
            historicalLocation = historicalLocation with { SelfLink = $"{_config.BasePath}/HistoricalLocations({historicalLocation.Id})" };

            // Handle expansions
            if (expand?.Properties.Contains("Thing") == true)
            {
                historicalLocation = historicalLocation with { Thing = await GetThingAsync(historicalLocation.ThingId, ct: ct) };
            }

            if (expand?.Properties.Contains("Locations") == true)
            {
                const string locationsSql = """
                    SELECT l.id::text, l.name, l.description, l.encoding_type,
                           ST_AsGeoJSON(l.location)::jsonb as location_geojson,
                           l.properties, l.created_at, l.updated_at
                    FROM sta_locations l
                    JOIN sta_historical_location_location hll ON l.id = hll.location_id
                    WHERE hll.historical_location_id = @HistoricalLocationId::uuid
                    """;

                var results = await _connection.QueryAsync<dynamic>(
                    new CommandDefinition(locationsSql, new { HistoricalLocationId = id }, cancellationToken: ct));

                // Use deferred execution to avoid materializing collection until accessed
                var locations = results.Select(r => new StaLocation
                {
                    Id = r.id,
                    Name = r.name,
                    Description = r.description,
                    EncodingType = r.encoding_type,
                    Geometry = _geoJsonReader.Read<Geometry>(r.location_geojson.ToString()),
                    Properties = r.properties,
                    CreatedAt = r.created_at,
                    UpdatedAt = r.updated_at,
                    SelfLink = $"{_config.BasePath}/Locations({r.id})"
                }).ToList();

                historicalLocation = historicalLocation with { Locations = locations };
            }
        }

        return historicalLocation;
    }

    public async Task<PagedResult<HistoricalLocation>> GetHistoricalLocationsAsync(QueryOptions options, CancellationToken ct = default)
    {
        var sql = "SELECT id::text, thing_id::text, time, created_at FROM sta_historical_locations";
        var countSql = "SELECT COUNT(*) FROM sta_historical_locations";
        var parameters = new DynamicParameters();

        // Apply filters
        if (options.Filter != null)
        {
            var whereClause = TranslateFilter(options.Filter, parameters);
            sql += $" WHERE {whereClause}";
            countSql += $" WHERE {whereClause}";
        }

        // Apply ordering
        if (options.OrderBy?.Count > 0)
        {
            var orderClauses = options.OrderBy.Select(o =>
                $"{o.Property} {(o.Direction == SortDirection.Descending ? "DESC" : "ASC")}");
            sql += $" ORDER BY {string.Join(", ", orderClauses)}";
        }
        else
        {
            sql += " ORDER BY time DESC";
        }

        // Apply pagination
        var limit = Math.Min(options.Top ?? 100, 10000);
        var offset = options.Skip ?? 0;
        sql += $" LIMIT {limit} OFFSET {offset}";

        var historicalLocations = await _connection.QueryAsync<HistoricalLocation>(
            new CommandDefinition(sql, parameters, cancellationToken: ct));

        // Use deferred execution for projection to avoid unnecessary materialization
        var historicalLocationsWithLinks = historicalLocations.Select(hl => hl with { SelfLink = $"{_config.BasePath}/HistoricalLocations({hl.Id})" });

        long? totalCount = null;
        if (options.Count)
        {
            totalCount = await _connection.ExecuteScalarAsync<long>(
                new CommandDefinition(countSql, parameters, cancellationToken: ct));
        }

        string? nextLink = null;
        if (totalCount.HasValue && offset + limit < totalCount.Value)
        {
            nextLink = $"{_config.BasePath}/HistoricalLocations?$skip={offset + limit}&$top={limit}";
        }

        return new PagedResult<HistoricalLocation>
        {
            Items = historicalLocationsWithLinks.ToList(),
            TotalCount = totalCount,
            NextLink = nextLink
        };
    }

    // ============================================================================
    // Sensor operations
    // ============================================================================

    public async Task<Sensor?> GetSensorAsync(string id, ExpandOptions? expand = null, CancellationToken ct = default)
    {
        const string sql = """
            SELECT id::text, name, description, encoding_type, metadata, properties, created_at, updated_at
            FROM sta_sensors
            WHERE id = @Id::uuid
            """;

        var sensor = await _connection.QuerySingleOrDefaultAsync<Sensor>(
            new CommandDefinition(sql, new { Id = id }, cancellationToken: ct));

        if (sensor != null)
        {
            sensor = sensor with { SelfLink = $"{_config.BasePath}/Sensors({sensor.Id})" };
        }

        return sensor;
    }

    public async Task<PagedResult<Sensor>> GetSensorsAsync(QueryOptions options, CancellationToken ct = default)
    {
        var sql = "SELECT id::text, name, description, encoding_type, metadata, properties, created_at, updated_at FROM sta_sensors";
        var countSql = "SELECT COUNT(*) FROM sta_sensors";
        var parameters = new DynamicParameters();

        if (options.Filter != null)
        {
            var whereClause = TranslateFilter(options.Filter, parameters);
            sql += $" WHERE {whereClause}";
            countSql += $" WHERE {whereClause}";
        }

        if (options.OrderBy?.Count > 0)
        {
            var orderClauses = options.OrderBy.Select(o =>
                $"{o.Property} {(o.Direction == SortDirection.Descending ? "DESC" : "ASC")}");
            sql += $" ORDER BY {string.Join(", ", orderClauses)}";
        }
        else
        {
            sql += " ORDER BY created_at DESC";
        }

        var limit = Math.Min(options.Top ?? 100, 10000);
        var offset = options.Skip ?? 0;
        sql += $" LIMIT {limit} OFFSET {offset}";

        var sensors = await _connection.QueryAsync<Sensor>(
            new CommandDefinition(sql, parameters, cancellationToken: ct));

        // Use deferred execution for projection to avoid unnecessary materialization
        var sensorsWithLinks = sensors.Select(s => s with { SelfLink = $"{_config.BasePath}/Sensors({s.Id})" });

        long? totalCount = null;
        if (options.Count)
        {
            totalCount = await _connection.ExecuteScalarAsync<long>(
                new CommandDefinition(countSql, parameters, cancellationToken: ct));
        }

        string? nextLink = null;
        if (totalCount.HasValue && offset + limit < totalCount.Value)
        {
            nextLink = $"{_config.BasePath}/Sensors?$skip={offset + limit}&$top={limit}";
        }

        return new PagedResult<Sensor>
        {
            Items = sensorsWithLinks.ToList(),
            TotalCount = totalCount,
            NextLink = nextLink
        };
    }

    public async Task<Sensor> CreateSensorAsync(Sensor sensor, CancellationToken ct = default)
    {
        const string sql = """
            INSERT INTO sta_sensors (name, description, encoding_type, metadata, properties)
            VALUES (@Name, @Description, @EncodingType, @Metadata, @Properties::jsonb)
            RETURNING id::text, name, description, encoding_type, metadata, properties, created_at, updated_at
            """;

        var created = await _connection.QuerySingleAsync<Sensor>(
            new CommandDefinition(sql, new
            {
                sensor.Name,
                sensor.Description,
                sensor.EncodingType,
                sensor.Metadata,
                Properties = sensor.Properties != null ? JsonSerializer.Serialize(sensor.Properties) : null
            }, cancellationToken: ct));

        created = created with { SelfLink = $"{_config.BasePath}/Sensors({created.Id})" };

        _logger.LogInformation("Created Sensor {SensorId} with name '{Name}'", created.Id, created.Name);

        return created;
    }

    public async Task<Sensor> UpdateSensorAsync(string id, Sensor sensor, CancellationToken ct = default)
    {
        const string sql = """
            UPDATE sta_sensors
            SET
                name = COALESCE(@Name, name),
                description = COALESCE(@Description, description),
                encoding_type = COALESCE(@EncodingType, encoding_type),
                metadata = COALESCE(@Metadata, metadata),
                properties = COALESCE(@Properties::jsonb, properties)
            WHERE id = @Id::uuid
            RETURNING id::text, name, description, encoding_type, metadata, properties, created_at, updated_at
            """;

        var updated = await _connection.QuerySingleAsync<Sensor>(
            new CommandDefinition(sql, new
            {
                Id = id,
                sensor.Name,
                sensor.Description,
                sensor.EncodingType,
                sensor.Metadata,
                Properties = sensor.Properties != null ? JsonSerializer.Serialize(sensor.Properties) : null
            }, cancellationToken: ct));

        updated = updated with { SelfLink = $"{_config.BasePath}/Sensors({updated.Id})" };

        _logger.LogInformation("Updated Sensor {SensorId}", id);

        return updated;
    }

    public async Task DeleteSensorAsync(string id, CancellationToken ct = default)
    {
        const string sql = "DELETE FROM sta_sensors WHERE id = @Id::uuid";

        await _connection.ExecuteAsync(
            new CommandDefinition(sql, new { Id = id }, cancellationToken: ct));

        _logger.LogInformation("Deleted Sensor {SensorId}", id);
    }

    // ============================================================================
    // ObservedProperty operations
    // ============================================================================

    public async Task<ObservedProperty?> GetObservedPropertyAsync(string id, ExpandOptions? expand = null, CancellationToken ct = default)
    {
        const string sql = """
            SELECT id::text, name, description, definition, properties, created_at, updated_at
            FROM sta_observed_properties
            WHERE id = @Id::uuid
            """;

        var observedProperty = await _connection.QuerySingleOrDefaultAsync<ObservedProperty>(
            new CommandDefinition(sql, new { Id = id }, cancellationToken: ct));

        if (observedProperty != null)
        {
            observedProperty = observedProperty with { SelfLink = $"{_config.BasePath}/ObservedProperties({observedProperty.Id})" };
        }

        return observedProperty;
    }

    public async Task<PagedResult<ObservedProperty>> GetObservedPropertiesAsync(QueryOptions options, CancellationToken ct = default)
    {
        var sql = "SELECT id::text, name, description, definition, properties, created_at, updated_at FROM sta_observed_properties";
        var countSql = "SELECT COUNT(*) FROM sta_observed_properties";
        var parameters = new DynamicParameters();

        if (options.Filter != null)
        {
            var whereClause = TranslateFilter(options.Filter, parameters);
            sql += $" WHERE {whereClause}";
            countSql += $" WHERE {whereClause}";
        }

        if (options.OrderBy?.Count > 0)
        {
            var orderClauses = options.OrderBy.Select(o =>
                $"{o.Property} {(o.Direction == SortDirection.Descending ? "DESC" : "ASC")}");
            sql += $" ORDER BY {string.Join(", ", orderClauses)}";
        }
        else
        {
            sql += " ORDER BY name";
        }

        var limit = Math.Min(options.Top ?? 100, 10000);
        var offset = options.Skip ?? 0;
        sql += $" LIMIT {limit} OFFSET {offset}";

        var observedProperties = await _connection.QueryAsync<ObservedProperty>(
            new CommandDefinition(sql, parameters, cancellationToken: ct));

        // Use deferred execution for projection to avoid unnecessary materialization
        var observedPropertiesWithLinks = observedProperties.Select(op => op with { SelfLink = $"{_config.BasePath}/ObservedProperties({op.Id})" });

        long? totalCount = null;
        if (options.Count)
        {
            totalCount = await _connection.ExecuteScalarAsync<long>(
                new CommandDefinition(countSql, parameters, cancellationToken: ct));
        }

        string? nextLink = null;
        if (totalCount.HasValue && offset + limit < totalCount.Value)
        {
            nextLink = $"{_config.BasePath}/ObservedProperties?$skip={offset + limit}&$top={limit}";
        }

        return new PagedResult<ObservedProperty>
        {
            Items = observedPropertiesWithLinks.ToList(),
            TotalCount = totalCount,
            NextLink = nextLink
        };
    }

    public async Task<ObservedProperty> CreateObservedPropertyAsync(ObservedProperty observedProperty, CancellationToken ct = default)
    {
        const string sql = """
            INSERT INTO sta_observed_properties (name, description, definition, properties)
            VALUES (@Name, @Description, @Definition, @Properties::jsonb)
            RETURNING id::text, name, description, definition, properties, created_at, updated_at
            """;

        var created = await _connection.QuerySingleAsync<ObservedProperty>(
            new CommandDefinition(sql, new
            {
                observedProperty.Name,
                observedProperty.Description,
                observedProperty.Definition,
                Properties = observedProperty.Properties != null ? JsonSerializer.Serialize(observedProperty.Properties) : null
            }, cancellationToken: ct));

        created = created with { SelfLink = $"{_config.BasePath}/ObservedProperties({created.Id})" };

        _logger.LogInformation("Created ObservedProperty {ObservedPropertyId} with definition '{Definition}'", created.Id, created.Definition);

        return created;
    }

    public async Task<ObservedProperty> UpdateObservedPropertyAsync(string id, ObservedProperty observedProperty, CancellationToken ct = default)
    {
        const string sql = """
            UPDATE sta_observed_properties
            SET
                name = COALESCE(@Name, name),
                description = COALESCE(@Description, description),
                definition = COALESCE(@Definition, definition),
                properties = COALESCE(@Properties::jsonb, properties)
            WHERE id = @Id::uuid
            RETURNING id::text, name, description, definition, properties, created_at, updated_at
            """;

        var updated = await _connection.QuerySingleAsync<ObservedProperty>(
            new CommandDefinition(sql, new
            {
                Id = id,
                observedProperty.Name,
                observedProperty.Description,
                observedProperty.Definition,
                Properties = observedProperty.Properties != null ? JsonSerializer.Serialize(observedProperty.Properties) : null
            }, cancellationToken: ct));

        updated = updated with { SelfLink = $"{_config.BasePath}/ObservedProperties({updated.Id})" };

        _logger.LogInformation("Updated ObservedProperty {ObservedPropertyId}", id);

        return updated;
    }

    public async Task DeleteObservedPropertyAsync(string id, CancellationToken ct = default)
    {
        const string sql = "DELETE FROM sta_observed_properties WHERE id = @Id::uuid";

        await _connection.ExecuteAsync(
            new CommandDefinition(sql, new { Id = id }, cancellationToken: ct));

        _logger.LogInformation("Deleted ObservedProperty {ObservedPropertyId}", id);
    }

    // ============================================================================
    // FeatureOfInterest operations
    // ============================================================================

    public async Task<FeatureOfInterest?> GetFeatureOfInterestAsync(string id, ExpandOptions? expand = null, CancellationToken ct = default)
    {
        const string sql = """
            SELECT
                id::text,
                name,
                description,
                encoding_type,
                ST_AsGeoJSON(feature)::jsonb as feature_geojson,
                properties,
                created_at,
                updated_at
            FROM sta_features_of_interest
            WHERE id = @Id::uuid
            """;

        var result = await _connection.QuerySingleOrDefaultAsync<dynamic>(
            new CommandDefinition(sql, new { Id = id }, cancellationToken: ct));

        if (result == null)
            return null;

        var featureOfInterest = new FeatureOfInterest
        {
            Id = result.id,
            Name = result.name,
            Description = result.description,
            EncodingType = result.encoding_type,
            Feature = result.feature_geojson != null
                ? _geoJsonReader.Read<Geometry>(result.feature_geojson.ToString())
                : null!,
            Properties = result.properties != null
                ? JsonSerializer.Deserialize<Dictionary<string, object>>(result.properties.ToString())
                : null,
            CreatedAt = result.created_at,
            UpdatedAt = result.updated_at,
            SelfLink = $"{_config.BasePath}/FeaturesOfInterest({result.id})"
        };

        // Handle expansions
        if (expand?.Properties.Contains("Observations") == true)
        {
            var observations = await GetObservationsAsync(
                new QueryOptions
                {
                    Filter = new ComparisonExpression
                    {
                        Property = "FeatureOfInterestId",
                        Operator = ComparisonOperator.Equals,
                        Value = id
                    }
                },
                ct);
            featureOfInterest = featureOfInterest with { Observations = observations.Items };
        }

        return featureOfInterest;
    }

    public async Task<PagedResult<FeatureOfInterest>> GetFeaturesOfInterestAsync(QueryOptions options, CancellationToken ct = default)
    {
        var sqlBuilder = new StringBuilder("""
            SELECT
                id::text,
                name,
                description,
                encoding_type,
                ST_AsGeoJSON(feature)::jsonb as feature_geojson,
                properties,
                created_at,
                updated_at
            FROM sta_features_of_interest
            """);

        var parameters = new DynamicParameters();

        // Apply filtering
        if (options.Filter != null)
        {
            sqlBuilder.AppendLine(" WHERE " + TranslateFilter(options.Filter, parameters));
        }

        // Apply ordering
        if (options.OrderBy?.Any() == true)
        {
            sqlBuilder.AppendLine(" ORDER BY " + string.Join(", ",
                options.OrderBy.Select(o => $"{o.Property} {(o.Direction == SortDirection.Ascending ? "ASC" : "DESC")}")));
        }
        else
        {
            sqlBuilder.AppendLine(" ORDER BY created_at DESC");
        }

        // Apply pagination
        var limit = options.Top ?? 100;
        var offset = options.Skip ?? 0;

        sqlBuilder.AppendLine(" LIMIT @Limit OFFSET @Offset");
        parameters.Add("Limit", limit);
        parameters.Add("Offset", offset);

        var results = await _connection.QueryAsync<dynamic>(
            new CommandDefinition(sqlBuilder.ToString(), parameters, cancellationToken: ct));

        // Use deferred execution for projection to avoid unnecessary materialization
        var items = results.Select(r => new FeatureOfInterest
        {
            Id = r.id,
            Name = r.name,
            Description = r.description,
            EncodingType = r.encoding_type,
            Feature = r.feature_geojson != null
                ? _geoJsonReader.Read<Geometry>(r.feature_geojson.ToString())
                : null!,
            Properties = r.properties != null
                ? JsonSerializer.Deserialize<Dictionary<string, object>>(r.properties.ToString())
                : null,
            CreatedAt = r.created_at,
            UpdatedAt = r.updated_at,
            SelfLink = $"{_config.BasePath}/FeaturesOfInterest({r.id})"
        });

        // Get total count if requested
        long? totalCount = null;
        if (options.Count)
        {
            var countSql = "SELECT COUNT(*) FROM sta_features_of_interest";
            if (options.Filter != null)
            {
                var countParams = new DynamicParameters();
                countSql += " WHERE " + TranslateFilter(options.Filter, countParams);
                totalCount = await _connection.ExecuteScalarAsync<long>(
                    new CommandDefinition(countSql, countParams, cancellationToken: ct));
            }
            else
            {
                totalCount = await _connection.ExecuteScalarAsync<long>(
                    new CommandDefinition(countSql, cancellationToken: ct));
            }
        }

        return new PagedResult<FeatureOfInterest>
        {
            Items = items.ToList(),
            TotalCount = totalCount
        };
    }

    public async Task<FeatureOfInterest> CreateFeatureOfInterestAsync(FeatureOfInterest featureOfInterest, CancellationToken ct = default)
    {
        var featureGeoJson = featureOfInterest.Feature != null
            ? _geoJsonWriter.Write(featureOfInterest.Feature)
            : null;

        const string sql = """
            INSERT INTO sta_features_of_interest (
                name,
                description,
                encoding_type,
                feature,
                properties
            )
            VALUES (
                @Name,
                @Description,
                @EncodingType,
                ST_GeomFromGeoJSON(@FeatureGeoJson),
                @Properties::jsonb
            )
            RETURNING
                id::text,
                name,
                description,
                encoding_type,
                ST_AsGeoJSON(feature)::jsonb as feature_geojson,
                properties,
                created_at,
                updated_at
            """;

        var result = await _connection.QuerySingleAsync<dynamic>(
            new CommandDefinition(sql, new
            {
                featureOfInterest.Name,
                featureOfInterest.Description,
                featureOfInterest.EncodingType,
                FeatureGeoJson = featureGeoJson,
                Properties = featureOfInterest.Properties != null
                    ? JsonSerializer.Serialize(featureOfInterest.Properties)
                    : null
            },
            cancellationToken: ct));

        var created = new FeatureOfInterest
        {
            Id = result.id,
            Name = result.name,
            Description = result.description,
            EncodingType = result.encoding_type,
            Feature = result.feature_geojson != null
                ? _geoJsonReader.Read<Geometry>(result.feature_geojson.ToString())
                : null!,
            Properties = result.properties != null
                ? JsonSerializer.Deserialize<Dictionary<string, object>>(result.properties.ToString())
                : null,
            CreatedAt = result.created_at,
            UpdatedAt = result.updated_at,
            SelfLink = $"{_config.BasePath}/FeaturesOfInterest({result.id})"
        };

        _logger.LogInformation("Created FeatureOfInterest {FeatureOfInterestId}", created.Id);

        return created;
    }

    public async Task<FeatureOfInterest> UpdateFeatureOfInterestAsync(string id, FeatureOfInterest featureOfInterest, CancellationToken ct = default)
    {
        var featureGeoJson = featureOfInterest.Feature != null
            ? _geoJsonWriter.Write(featureOfInterest.Feature)
            : null;

        const string sql = """
            UPDATE sta_features_of_interest
            SET
                name = COALESCE(@Name, name),
                description = COALESCE(@Description, description),
                encoding_type = COALESCE(@EncodingType, encoding_type),
                feature = COALESCE(ST_GeomFromGeoJSON(@FeatureGeoJson), feature),
                properties = COALESCE(@Properties::jsonb, properties),
                updated_at = now()
            WHERE id = @Id::uuid
            RETURNING
                id::text,
                name,
                description,
                encoding_type,
                ST_AsGeoJSON(feature)::jsonb as feature_geojson,
                properties,
                created_at,
                updated_at
            """;

        var result = await _connection.QuerySingleOrDefaultAsync<dynamic>(
            new CommandDefinition(sql, new
            {
                Id = id,
                featureOfInterest.Name,
                featureOfInterest.Description,
                featureOfInterest.EncodingType,
                FeatureGeoJson = featureGeoJson,
                Properties = featureOfInterest.Properties != null
                    ? JsonSerializer.Serialize(featureOfInterest.Properties)
                    : null
            },
            cancellationToken: ct));

        if (result == null)
            throw new InvalidOperationException($"FeatureOfInterest {id} not found");

        var updated = new FeatureOfInterest
        {
            Id = result.id,
            Name = result.name,
            Description = result.description,
            EncodingType = result.encoding_type,
            Feature = result.feature_geojson != null
                ? _geoJsonReader.Read<Geometry>(result.feature_geojson.ToString())
                : null!,
            Properties = result.properties != null
                ? JsonSerializer.Deserialize<Dictionary<string, object>>(result.properties.ToString())
                : null,
            CreatedAt = result.created_at,
            UpdatedAt = result.updated_at,
            SelfLink = $"{_config.BasePath}/FeaturesOfInterest({result.id})"
        };

        _logger.LogInformation("Updated FeatureOfInterest {FeatureOfInterestId}", id);

        return updated;
    }

    public async Task DeleteFeatureOfInterestAsync(string id, CancellationToken ct = default)
    {
        const string sql = """
            DELETE FROM sta_features_of_interest
            WHERE id = @Id::uuid
            """;

        var rowsAffected = await _connection.ExecuteAsync(
            new CommandDefinition(sql, new { Id = id }, cancellationToken: ct));

        if (rowsAffected == 0)
            throw new InvalidOperationException($"FeatureOfInterest {id} not found");

        _logger.LogInformation("Deleted FeatureOfInterest {FeatureOfInterestId}", id);
    }

    public async Task<FeatureOfInterest> GetOrCreateFeatureOfInterestAsync(
        string name,
        string description,
        Geometry geometry,
        CancellationToken ct = default)
    {
        var featureGeoJson = geometry != null ? _geoJsonWriter.Write(geometry) : null;

        // First, try to find an existing FeatureOfInterest with the same geometry
        const string findSql = """
            SELECT
                id::text,
                name,
                description,
                encoding_type,
                ST_AsGeoJSON(feature)::jsonb as feature_geojson,
                properties,
                created_at,
                updated_at
            FROM sta_features_of_interest
            WHERE ST_Equals(feature, ST_GeomFromGeoJSON(@FeatureGeoJson))
            LIMIT 1
            """;

        var existing = await _connection.QuerySingleOrDefaultAsync<dynamic>(
            new CommandDefinition(findSql, new { FeatureGeoJson = featureGeoJson }, cancellationToken: ct));

        if (existing != null)
        {
            var existingId = (string)existing.id;
            _logger.LogDebug("Found existing FeatureOfInterest {FeatureOfInterestId} with matching geometry", existingId);

            return new FeatureOfInterest
            {
                Id = existingId,
                Name = existing.name,
                Description = existing.description,
                EncodingType = existing.encoding_type,
                Feature = existing.feature_geojson != null
                    ? _geoJsonReader.Read<Geometry>(existing.feature_geojson.ToString())
                    : null!,
                Properties = existing.properties != null
                    ? JsonSerializer.Deserialize<Dictionary<string, object>>(existing.properties.ToString())
                    : null,
                CreatedAt = existing.created_at,
                UpdatedAt = existing.updated_at,
                SelfLink = $"{_config.BasePath}/FeaturesOfInterest({existingId})"
            };
        }

        // If not found, create a new FeatureOfInterest
        const string createSql = """
            INSERT INTO sta_features_of_interest (
                name,
                description,
                encoding_type,
                feature
            )
            VALUES (
                @Name,
                @Description,
                'application/geo+json',
                ST_GeomFromGeoJSON(@FeatureGeoJson)
            )
            RETURNING
                id::text,
                name,
                description,
                encoding_type,
                ST_AsGeoJSON(feature)::jsonb as feature_geojson,
                properties,
                created_at,
                updated_at
            """;

        var created = await _connection.QuerySingleAsync<dynamic>(
            new CommandDefinition(createSql, new
            {
                Name = name,
                Description = description,
                FeatureGeoJson = featureGeoJson
            },
            cancellationToken: ct));

        var createdId = (string)created.id;
        _logger.LogInformation("Created new FeatureOfInterest {FeatureOfInterestId}", createdId);

        return new FeatureOfInterest
        {
            Id = createdId,
            Name = created.name,
            Description = created.description,
            EncodingType = created.encoding_type,
            Feature = created.feature_geojson != null
                ? _geoJsonReader.Read<Geometry>(created.feature_geojson.ToString())
                : null!,
            Properties = created.properties != null
                ? JsonSerializer.Deserialize<Dictionary<string, object>>(created.properties.ToString())
                : null,
            CreatedAt = created.created_at,
            UpdatedAt = created.updated_at,
            SelfLink = $"{_config.BasePath}/FeaturesOfInterest({createdId})"
        };
    }
}
