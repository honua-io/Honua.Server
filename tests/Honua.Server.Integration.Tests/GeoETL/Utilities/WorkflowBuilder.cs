// Copyright (c) 2025 HonuaIO
// Licensed under the Elastic License 2.0. See LICENSE file in the project root for full license information.

using Honua.Server.Enterprise.ETL.Models;
using System;
using System.Collections.Generic;

namespace Honua.Server.Integration.Tests.GeoETL.Utilities;

/// <summary>
/// Fluent API for building workflow definitions in tests
/// </summary>
public class WorkflowBuilder
{
    private readonly WorkflowDefinition _workflow;
    private readonly List<WorkflowNode> _nodes = new();
    private readonly List<WorkflowEdge> _edges = new();
    private string? _lastNodeId;

    private WorkflowBuilder(Guid tenantId, Guid userId)
    {
        _workflow = new WorkflowDefinition
        {
            TenantId = tenantId,
            CreatedBy = userId,
            Metadata = new WorkflowMetadata
            {
                Name = "Test Workflow",
                Description = "Generated by WorkflowBuilder"
            }
        };
    }

    public static WorkflowBuilder Create(Guid? tenantId = null, Guid? userId = null)
    {
        return new WorkflowBuilder(
            tenantId ?? Guid.NewGuid(),
            userId ?? Guid.NewGuid()
        );
    }

    public WorkflowBuilder WithName(string name)
    {
        _workflow.Metadata.Name = name;
        return this;
    }

    public WorkflowBuilder WithDescription(string description)
    {
        _workflow.Metadata.Description = description;
        return this;
    }

    public WorkflowBuilder WithCategory(string category)
    {
        _workflow.Metadata.Category = category;
        return this;
    }

    public WorkflowBuilder WithTag(string tag)
    {
        _workflow.Metadata.Tags.Add(tag);
        return this;
    }

    public WorkflowBuilder WithParameter(string name, string type, object? defaultValue = null, bool required = false)
    {
        _workflow.Parameters[name] = new WorkflowParameter
        {
            Name = name,
            Type = type,
            DefaultValue = defaultValue,
            Required = required
        };
        return this;
    }

    public WorkflowBuilder AddNode(string id, string type, Dictionary<string, object>? parameters = null, string? name = null)
    {
        var node = new WorkflowNode
        {
            Id = id,
            Type = type,
            Name = name,
            Parameters = parameters ?? new Dictionary<string, object>()
        };
        _nodes.Add(node);
        _lastNodeId = id;
        return this;
    }

    public WorkflowBuilder WithSource(string id, string type, Dictionary<string, object>? parameters = null)
    {
        return AddNode(id, $"data_source.{type}", parameters, $"Source: {id}");
    }

    public WorkflowBuilder WithFileSource(string id, string geojson)
    {
        return WithSource(id, "file", new Dictionary<string, object>
        {
            ["geojson"] = geojson
        });
    }

    public WorkflowBuilder WithPostGisSource(string id, string table, string? geometryColumn = "geom", string? query = null)
    {
        var parameters = new Dictionary<string, object>
        {
            ["table"] = table,
            ["geometry_column"] = geometryColumn ?? "geom"
        };

        if (query != null)
        {
            parameters["query"] = query;
        }

        return WithSource(id, "postgis", parameters);
    }

    public WorkflowBuilder WithGeoPackageSource(string id, string filePath, string? layerName = null)
    {
        var parameters = new Dictionary<string, object>
        {
            ["file_path"] = filePath
        };

        if (layerName != null)
        {
            parameters["layer_name"] = layerName;
        }

        return WithSource(id, "geopackage", parameters);
    }

    public WorkflowBuilder WithTransform(string id, string operation, Dictionary<string, object>? parameters = null)
    {
        return AddNode(id, $"geoprocessing.{operation}", parameters, $"Transform: {operation}");
    }

    public WorkflowBuilder WithBuffer(string id, double distance, string unit = "meters")
    {
        return WithTransform(id, "buffer", new Dictionary<string, object>
        {
            ["distance"] = distance,
            ["unit"] = unit
        });
    }

    public WorkflowBuilder WithIntersection(string id)
    {
        return WithTransform(id, "intersection");
    }

    public WorkflowBuilder WithUnion(string id)
    {
        return WithTransform(id, "union");
    }

    public WorkflowBuilder WithDifference(string id)
    {
        return WithTransform(id, "difference");
    }

    public WorkflowBuilder WithSimplify(string id, double tolerance)
    {
        return WithTransform(id, "simplify", new Dictionary<string, object>
        {
            ["tolerance"] = tolerance
        });
    }

    public WorkflowBuilder WithSink(string id, string type, Dictionary<string, object>? parameters = null)
    {
        return AddNode(id, $"data_sink.{type}", parameters, $"Sink: {type}");
    }

    public WorkflowBuilder WithGeoJsonSink(string id, string? outputPath = null)
    {
        var parameters = new Dictionary<string, object>();
        if (outputPath != null)
        {
            parameters["output_path"] = outputPath;
        }

        return WithSink(id, "geojson", parameters);
    }

    public WorkflowBuilder WithOutputSink(string id)
    {
        return WithSink(id, "output");
    }

    public WorkflowBuilder WithPostGisSink(string id, string table, string? geometryColumn = "geom")
    {
        return WithSink(id, "postgis", new Dictionary<string, object>
        {
            ["table"] = table,
            ["geometry_column"] = geometryColumn ?? "geom"
        });
    }

    public WorkflowBuilder WithGeoPackageSink(string id, string outputPath, string? layerName = null)
    {
        var parameters = new Dictionary<string, object>
        {
            ["output_path"] = outputPath
        };

        if (layerName != null)
        {
            parameters["layer_name"] = layerName;
        }

        return WithSink(id, "geopackage", parameters);
    }

    public WorkflowBuilder AddEdge(string from, string to, string? label = null)
    {
        _edges.Add(new WorkflowEdge
        {
            From = from,
            To = to,
            Label = label
        });
        return this;
    }

    public WorkflowBuilder ConnectFromLast(string toId)
    {
        if (_lastNodeId == null)
        {
            throw new InvalidOperationException("No previous node to connect from");
        }

        return AddEdge(_lastNodeId, toId);
    }

    public WorkflowBuilder ChainAfterLast(string id, string type, Dictionary<string, object>? parameters = null)
    {
        if (_lastNodeId == null)
        {
            throw new InvalidOperationException("No previous node to chain from");
        }

        var previousNodeId = _lastNodeId;
        AddNode(id, type, parameters);
        AddEdge(previousNodeId, id);
        return this;
    }

    public WorkflowDefinition Build()
    {
        _workflow.Nodes = _nodes;
        _workflow.Edges = _edges;
        return _workflow;
    }

    /// <summary>
    /// Creates a simple source -> sink workflow
    /// </summary>
    public static WorkflowDefinition CreateSimple(Guid? tenantId = null, Guid? userId = null)
    {
        return Create(tenantId, userId)
            .WithName("Simple Workflow")
            .WithFileSource("source", @"{""type"":""FeatureCollection"",""features"":[]}")
            .WithOutputSink("output")
            .AddEdge("source", "output")
            .Build();
    }

    /// <summary>
    /// Creates a source -> buffer -> sink workflow
    /// </summary>
    public static WorkflowDefinition CreateBufferWorkflow(Guid? tenantId = null, Guid? userId = null, double bufferDistance = 100)
    {
        return Create(tenantId, userId)
            .WithName("Buffer Workflow")
            .WithFileSource("source", @"{""type"":""FeatureCollection"",""features"":[]}")
            .WithBuffer("buffer", bufferDistance)
            .WithOutputSink("output")
            .AddEdge("source", "buffer")
            .AddEdge("buffer", "output")
            .Build();
    }

    /// <summary>
    /// Creates a multi-node workflow: source -> buffer -> simplify -> sink
    /// </summary>
    public static WorkflowDefinition CreateMultiNodeWorkflow(Guid? tenantId = null, Guid? userId = null)
    {
        return Create(tenantId, userId)
            .WithName("Multi-Node Workflow")
            .WithFileSource("source", @"{""type"":""FeatureCollection"",""features"":[]}")
            .WithBuffer("buffer", 50)
            .WithSimplify("simplify", 10)
            .WithOutputSink("output")
            .AddEdge("source", "buffer")
            .AddEdge("buffer", "simplify")
            .AddEdge("simplify", "output")
            .Build();
    }
}
